# Test end-to-end fuzzing. This test focuses on return value reuse in fz.Chain.
# See github.com/thepudds/fzgen/examples/inputs/return-reuse for comments about target.
# Requires -end2end flag for 'go test'.
#
# Some test details:
#   1. We assume a 1.18 gotip is in the path. (We exit early if no gotip is in path,
#      or if it appears to be the wrong version).
#   2. To just run this script, execute from the fzgen directory:
#      go test -run=TestScripts/return_reuse_fuzzing -end2end
#   3. Adding '-v -testwork' shows more detail, including the temp dir location,
#      which will be left behind for inspection or manual debugging.

[!exec:gotip$exe] skip 'skipping because no gotip found in path'

# Validate result is Go 1.18+. 
exec gotip version
# We do not envision a Go 2.
stdout 'go version.*go1\.(1[8-9]|[2-9][0-9]|[1-9][0-9][0-9])'

# Set up a usable module, including the run time dependency for fzgen/fuzzer
# Note: we force use of our local copy of fzgen via a 'replace' directive.
go mod init temp
go mod edit -replace github.com/thepudds/fzgen=$FZLOCALDIR
go get github.com/thepudds/fzgen/fuzzer
go list -m all

# Create our set of wrappers, which will be chainable.
fzgen -chain github.com/thepudds/fzgen/examples/inputs/return-reuse
exists autofuzzchain_test.go

# TODO: consider making the cmd/go fuzzing deterministic with -parallel=1,
# but based on current GODEBUG=fuzzseed=N implementation, not sure if that is useful here.
# env GODEBUG=fuzzseed=1

# TODO: ideally would also start with an empty cached corpus, but that also slows down builds currently.
# Could do 'env GOCACHE=$WORK', or manually clean cache globally or surgically, or ...

# Let's go! Start fuzzing our autogenerated loop.
# This can take 20-30 sec to hit the desired panic.,
! exec gotip test -fuzz=. -fuzztime=60s
stdout 'panic: bingo'
